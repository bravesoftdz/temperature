#!/usr/bin/python

import os, parse, select, shutil, socket, subprocess, sys, time

outputfolder = 'run-qemu-output'

class TcpChannel:
    def __init__ (self, name, port):
        print name, port
        self.name = name
        self.port = port
        self.socket = socket.socket ()
        opened = False
        while not opened:
            try:
                self.socket.connect (('127.0.0.1', self.port))
                opened = True
            except:
                sleep (0.1)
        self.logfile = open ('{}/{}.txt'.format (outputfolder, self.name), 'a')
    def writeline (self, line, echo=False):
#       print '{}>>>>{}'.format (self.name, line)
        if echo:
            self.logfile.write ('{}>>>>{}\n'.format (self.name, line))
        self.socket.sendall (line + '\n')
    def writekeyboardline (self, line, echo=False):
#       print '{}>>>>{}'.format (self.name, line)
        if echo:
            self.logfile.write ('{}>>>>{}\n'.format (self.name, line))
        self.socket.sendall (line + '\r')
    def drain (self):
        print 'drain {}'.format (self.name)
        try:
            while ([], [], []) != select.select ([self.socket], [], [], 0):
                sleep (0.001, self.name)
                data = self.socket.recv (4096)
                self.logfile.write (data)
                if data == "":
                    break
        except:
            pass
    def finishquit (self, process):
        while process.returncode == None:
            sleep (0.001, 'quit ' + self.name)
            process.poll ()
            if ([], [], []) != select.select ([self.socket], [], [], 0):
                sys.stdout.write (self.socket.recv (1))
    def close (self):
        self.logfile.close ()
        self.socket.close ()

def bash (lines):
    for line in lines:
#       print 'bash >>', line
        subprocess.check_call (line, shell=True)

bash (['rm -rf {}/'.format (outputfolder),
       'mkdir -p {}'.format (outputfolder)])

qemuprocess = subprocess.Popen (["qemu-system-arm",
                                 "-M", "versatilepb",
                                 "-cpu", "cortex-a8",
                                 "-kernel", "kernel.bin",
                                 "-m", "256M",
                                 "-usb",
                                 "-display", "none",
                                 "-monitor", "tcp:127.0.0.1:38004,server",
                                 "-serial", "tcp:127.0.0.1:38000,server",
                                 "-serial", "tcp:127.0.0.1:38001,server",
                                 "-serial", "tcp:127.0.0.1:38002,server",
                                 "-serial", "tcp:127.0.0.1:38003,server"],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

# close parse

serial = {}
screennumber = 1
def drainall ():
    for i in serial:
        serial [i].drain ()
    monitor.drain ()
def screendump ():
    global screennumber
    monitor.writeline ('screendump {}/screen-{:02d}.ppm'.format (outputfolder, screennumber))
    screennumber = screennumber + 1
def sleep (seconds, message=''):
    print 'sleep {} {}'.format (seconds, message)
    time.sleep (seconds)

monitor = TcpChannel ('monitor', 38004)
for i in range (4):
    serial [i] = TcpChannel ('serial{}'.format (i),  38000 + i)

drainall ()
screendump ()
for s in serial:
    for i in range (1, 10):
        serial [s].writekeyboardline ('line {}'.format (i))
sleep (7)
screendump ()

drainall ()
monitor.writeline ('quit')
sleep (1)
drainall ()
monitor.finishquit (qemuprocess)

#print
#print 'qemu return code', qemuprocess.returncode

monitor.close ()
for i in serial:
    serial [i].close ()
